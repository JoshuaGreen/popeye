#if !defined(PIECES_ROSES_H)
#define PIECES_ROSES_H

#include "position/board.h"
#include "position/position.h"
#include "pieces/vectors.h"

/* Generation of moves for Rose and derived pieces.
 * The circle lines are generated in a clever way (which leads to
 * simple code):
 *
 * At the positions vec_knight_start to
 * vec_knight_start+(vec_knight_end-vec_knight_start) of the array
 * vec, we have the knight vectors twice in a row, in the order of the
 * knight's wheel. Each rose line is generated by sequentally adding
 * vec[k1], vec[k1+1] ... vec[k1+(vec_knight_end-vec_knight_start)]
 * (or the same vectors in opposite order) to the initial square.
 *
 * In calls to the generator functions, k2 should either be 0 or
 * (vec_knight_end-vec_knight_start)+1, and delta_k +1 or -1,
 * respectively, to cause k2, k2+delta_k, ... to assume values 0 ...
 * (vec_knight_end-vec_knight_start) or
 * (vec_knight_end-vec_knight_start)+1 ... 1.
 */

typedef enum
{
  rose_rotation_counterclockwise = -1,
  rose_rotation_clockwise = +1
} rose_rotation_direction;

square find_end_of_circle_line(square sq_departure,
                               vec_index_type vec_index_start,
                               vec_index_type *rotation,
                               rose_rotation_direction direction);

void rose_generate_moves(square sq_departure,
                         vec_index_type vec_range_start, vec_index_type vec_range_end);

void rao_generate_moves(square sq_departure,
                        vec_index_type vec_range_start, vec_index_type vec_range_end);

void roselion_generate_moves(square sq_departure,
                             vec_index_type vec_range_start, vec_index_type vec_range_end);

void rosehopper_generate_moves(square sq_departure,
                               vec_index_type vec_range_start, vec_index_type vec_range_end);

void roselocust_generate_moves(square sq_departure,
                               vec_index_type vec_range_start, vec_index_type vec_range_end);

#endif
